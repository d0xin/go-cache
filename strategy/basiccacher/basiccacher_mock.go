// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package basiccacher

import (
	"sync"
	"time"
)

var (
	lockCacherMockExpire sync.RWMutex
	lockCacherMockGet    sync.RWMutex
	lockCacherMockPut    sync.RWMutex
)

// CacherMock is a mock implementation of Cacher.
//
//     func TestSomethingThatUsesCacher(t *testing.T) {
//
//         // make and configure a mocked Cacher
//         mockedCacher := &CacherMock{
//             ExpireFunc: func(in1 string) error {
// 	               panic("TODO: mock out the Expire method")
//             },
//             GetFunc: func(in1 string) ([]byte, error) {
// 	               panic("TODO: mock out the Get method")
//             },
//             PutFunc: func(in1 string, in2 time.Time, in3 []byte) error {
// 	               panic("TODO: mock out the Put method")
//             },
//         }
//
//         // TODO: use mockedCacher in code that requires Cacher
//         //       and then make assertions.
//
//     }
type CacherMock struct {
	// ExpireFunc mocks the Expire method.
	ExpireFunc func(in1 string) error

	// GetFunc mocks the Get method.
	GetFunc func(in1 string) ([]byte, error)

	// PutFunc mocks the Put method.
	PutFunc func(in1 string, in2 time.Time, in3 []byte) error

	// calls tracks calls to the methods.
	calls struct {
		// Expire holds details about calls to the Expire method.
		Expire []struct {
			// In1 is the in1 argument value.
			In1 string
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// In1 is the in1 argument value.
			In1 string
		}
		// Put holds details about calls to the Put method.
		Put []struct {
			// In1 is the in1 argument value.
			In1 string
			// In2 is the in2 argument value.
			In2 time.Time
			// In3 is the in3 argument value.
			In3 []byte
		}
	}
}

// Expire calls ExpireFunc.
func (mock *CacherMock) Expire(in1 string) error {
	if mock.ExpireFunc == nil {
		panic("moq: CacherMock.ExpireFunc is nil but Cacher.Expire was just called")
	}
	callInfo := struct {
		In1 string
	}{
		In1: in1,
	}
	lockCacherMockExpire.Lock()
	mock.calls.Expire = append(mock.calls.Expire, callInfo)
	lockCacherMockExpire.Unlock()
	return mock.ExpireFunc(in1)
}

// ExpireCalls gets all the calls that were made to Expire.
// Check the length with:
//     len(mockedCacher.ExpireCalls())
func (mock *CacherMock) ExpireCalls() []struct {
	In1 string
} {
	var calls []struct {
		In1 string
	}
	lockCacherMockExpire.RLock()
	calls = mock.calls.Expire
	lockCacherMockExpire.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *CacherMock) Get(in1 string) ([]byte, error) {
	if mock.GetFunc == nil {
		panic("moq: CacherMock.GetFunc is nil but Cacher.Get was just called")
	}
	callInfo := struct {
		In1 string
	}{
		In1: in1,
	}
	lockCacherMockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	lockCacherMockGet.Unlock()
	return mock.GetFunc(in1)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedCacher.GetCalls())
func (mock *CacherMock) GetCalls() []struct {
	In1 string
} {
	var calls []struct {
		In1 string
	}
	lockCacherMockGet.RLock()
	calls = mock.calls.Get
	lockCacherMockGet.RUnlock()
	return calls
}

// Put calls PutFunc.
func (mock *CacherMock) Put(in1 string, in2 time.Time, in3 []byte) error {
	if mock.PutFunc == nil {
		panic("moq: CacherMock.PutFunc is nil but Cacher.Put was just called")
	}
	callInfo := struct {
		In1 string
		In2 time.Time
		In3 []byte
	}{
		In1: in1,
		In2: in2,
		In3: in3,
	}
	lockCacherMockPut.Lock()
	mock.calls.Put = append(mock.calls.Put, callInfo)
	lockCacherMockPut.Unlock()
	return mock.PutFunc(in1, in2, in3)
}

// PutCalls gets all the calls that were made to Put.
// Check the length with:
//     len(mockedCacher.PutCalls())
func (mock *CacherMock) PutCalls() []struct {
	In1 string
	In2 time.Time
	In3 []byte
} {
	var calls []struct {
		In1 string
		In2 time.Time
		In3 []byte
	}
	lockCacherMockPut.RLock()
	calls = mock.calls.Put
	lockCacherMockPut.RUnlock()
	return calls
}
