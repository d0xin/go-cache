//go:generate goautomock -o=../mock/cacher_mock.go Cacher

package cacher

import (
	"time"

	"github.com/fresh8/go-cache/engine/common"
	"github.com/fresh8/go-cache/joque"
)

type cacher struct {
	engine   common.Engine
	jobQueue chan joque.Job
}

// Cacher defines the interface for a caching system so it can be customised.
type Cacher interface {
	Setup(common.Engine)
	Get(string, time.Time, func() []byte) ([]byte, error)
	Expire(string) error
}

// NewCacher creates a new generic cacher with the given engine.
func NewCacher(engine common.Engine) Cacher {
	return cacher{
		engine:   engine,
		jobQueue: joque.Setup(5, 5),
	}
}

// Setup performs the initial actions to set the cacher up
func (c cacher) Setup(engine common.Engine) {
	c.engine = engine
}

func (c cacher) Get(key string, expires time.Time, regenerate func() []byte) (data []byte, err error) {
	if c.engine.Exists(key) {
		data, err = c.engine.Get(key)

		// Return, something went wrong
		if err != nil {
			return
		}

		// Return, data is fresh enough
		if !c.engine.IsExpired(key) {
			return
		}

		// Return, as data is being regenerated by another process
		if c.engine.IsLocked(key) {
			return
		}

		// Send the regenerate function to the job queue to be processed
		c.jobQueue <- func() {
			c.engine.Lock(key)
			defer c.engine.Unlock(key)

			data = regenerate()
			c.engine.Put(key, data, expires)
		}
		return
	}

	// If the key doesn't exist, generate it now and return
	data = regenerate()
	err = c.engine.Put(key, data, expires)

	return
}

// Expire the given key within the cache engine
func (c cacher) Expire(key string) error {
	return c.engine.Expire(key)
}
