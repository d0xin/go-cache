package cacher

import (
	"github.com/fresh8/go-cache/engine/common"
)

type cacher struct {
	engine common.Engine
}

// Cacher defines the interface for a caching system so it can be customised.
type Cacher interface {
	Setup(common.Engine)
	Get(string, func() []byte) ([]byte, error)
	Expire(string) error
}

// NewCacher creates a new generic cacher with the given engine.
func NewCacher(engine common.Engine) Cacher {
	return cacher{
		engine: engine,
	}
}

// Setup performs the initial actions to set the cacher up
func (c cacher) Setup(engine common.Engine) {
	c.engine = engine
}

func (c cacher) Get(key string, regenerate func() []byte) (data []byte, err error) {
	if c.engine.Exists(key) {
		data, err = c.engine.Get(key)

		// Return, something went wrong
		if err != nil {
			return
		}

		// Return, data is fresh enough
		if !c.engine.IsExpired(key) {
			return
		}

		// Return, as data is being regenerated by another process
		if c.engine.IsLocked(key) {
			return
		}

		// TODO: Implement background generation with work dispatcher
	}

	// If the key doesn't exist, generate it now and return
	data = regenerate()
	err = c.engine.Put(key, data)

	return
}

// Expire the given key within the cache engine
func (c cacher) Expire(key string) error {
	return c.engine.Expire(key)
}
